// scripts/buildAssetMap.mjs
import fs from "fs";
import path from "path";
import url from "url";

const ROOT = process.cwd();
const JSON_PATH = process.argv[2] || path.join(ROOT, "night.json");
const ASSETS_DIR = path.join(ROOT, "assets");
const OUT_FILE = path.join(ROOT, "scripts", "assetMap.js");

// ---------------- helpers ----------------
/**
 * Повертає відносний шлях у вигляді 'assets/...'
 * з різних форматів photoUri (unstable_path, прямий шлях у assets, тощо).
 * Якщо шлях не веде в /assets, повертає null.
 */
function extractAssetsRelPath(photoUri) {
  if (!photoUri || typeof photoUri !== "string") return null;

  // Випадок 1: URL з параметром unstable_path=.%2Fassets%2F...
  try {
    const maybeUrl = new url.URL(photoUri);
    const up = maybeUrl.searchParams.get("unstable_path");
    if (up) {
      const decoded = decodeURIComponent(up); // типово './assets/...'
      const cleaned = decoded.replace(/^\.?\//, ""); // прибираємо './' або '/'
      if (cleaned.startsWith("assets/")) return cleaned;
    }
  } catch (_) {
    // не URL — ідемо нижче
  }

  // Випадок 2: вже відносний шлях до assets
  if (photoUri.startsWith("./assets/") || photoUri.startsWith("/assets/") || photoUri.startsWith("assets/")) {
    const cleaned = photoUri.replace(/^\.?\//, "");
    return cleaned.startsWith("assets/") ? cleaned : null;
  }

  // Випадок 3: локальні тимчасові шляхи (file:// ... ImagePicker) — ігноруємо
  return null;
}

/** Рекурсивно іде по масиву об'єктів і витягує всі валідні assets-шляхи з photoUri */
function collectFromArray(arr) {
  const out = new Set();
  for (const item of arr || []) {
    const rel = extractAssetsRelPath(item?.photoUri);
    if (rel) out.add(rel);
  }
  return out;
}

/** Додає всі .png із кореня assets/ (тільки перший рівень) */
function collectFromAssetsRoot() {
  const out = new Set();
  if (!fs.existsSync(ASSETS_DIR)) return out;
  for (const file of fs.readdirSync(ASSETS_DIR)) {
    const full = path.join(ASSETS_DIR, file);
    const stat = fs.statSync(full);
    if (stat.isFile() && file.toLowerCase().endsWith(".png")) {
      out.add(path.posix.join("assets", file));
    }
  }
  return out;
}

/** Перевіряє існування файлу; якщо нема — лог warning і пропускає */
function filterExisting(relPaths) {
  const out = [];
  for (const rel of relPaths) {
    const abs = path.join(ROOT, rel);
    if (fs.existsSync(abs)) out.push(rel);
    else console.warn(`⚠ Відсутній файл: ${rel}`);
  }
  return out;
}

function buildMapObject(relPaths) {
  // Сортуємо для стабільності
  const sorted = [...relPaths].sort((a, b) => a.localeCompare(b));
  // Формуємо об'єкт-рядок
  const lines = sorted.map(
    (rel) => `  '${rel}': require('../${rel}'),`
  );
  const header = `/* ⚠️ AUTOGENERATED FILE – do not edit by hand.
   * Generated by scripts/buildAssetMap.mjs
   */`;
  const body = `export const ASSET_MAP = {\n${lines.join("\n")}\n};\n`;
  return `${header}\n\n${body}`;
}

// ---------------- main ----------------
function main() {
  if (!fs.existsSync(JSON_PATH)) {
    console.error(`❌ Не знайдено JSON: ${JSON_PATH}`);
    process.exit(1);
  }

  const raw = fs.readFileSync(JSON_PATH, "utf8");
  let data;
  try {
    data = JSON.parse(raw);
  } catch (e) {
    console.error("❌ Помилка парсингу JSON:", e.message);
    process.exit(1);
  }

  const rels = new Set();

  // Підтримуємо структуру: { ingredients: [...], cocktails: [...] }
  if (Array.isArray(data.ingredients)) {
    for (const p of collectFromArray(data.ingredients)) rels.add(p);
  }
  if (Array.isArray(data.cocktails)) {
    for (const p of collectFromArray(data.cocktails)) rels.add(p);
  }

  // Додатково: PNG з кореня assets/
  for (const p of collectFromAssetsRoot()) rels.add(p);

  // Перевіримо існування файлів
  const existing = filterExisting(rels);

  // Побудуємо та запишемо файл
  const outJs = buildMapObject(existing);
  fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });
  fs.writeFileSync(OUT_FILE, outJs, "utf8");

  console.log(`✔ Згенеровано ${existing.length} записів у ${path.relative(ROOT, OUT_FILE)}`);
}

main();
