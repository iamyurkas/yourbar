# Радикальні архітектурні зміни для прискорення оновлення інгредієнтів

## Вихідні обмеження
- Дані про інгредієнти зберігаються у SQLite; усі записуючі транзакції проходять через глобальну чергу `withWriteTransactionAsync`, яка виконує `BEGIN IMMEDIATE` та блокує write-конектор, доки операція не завершиться.【F:src/data/ingredients.ts†L206-L337】【F:src/data/sqlite.ts†L48-L207】
- Оновлення кешу доступності (`ingredientsAvailabilityCache`) відбувається повторно для повʼязаних коктейлів і брендів після кожної зміни, що теж виконується на JS-потоці.【F:src/domain/ingredientsAvailabilityCache.ts†L1-L96】

## Реалізовані зміни
1. **Оптимістичні оновлення UI.** На екранах `MyIngredients` та `AllIngredients` значення `inBar` тепер перемикається миттєво через локальне оновлення `Map`, а кеш доступності оновлюється інкрементально без очікування завершення SQL-транзакції.【F:src/screens/Ingredients/MyIngredientsScreen.tsx†L1-L210】【F:src/screens/Ingredients/AllIngredientsScreen.tsx†L1-L200】【F:src/domain/ingredientsAvailabilityCache.ts†L1-L96】
2. **Черга команд інгредієнтів.** Додано `IngredientCommandQueue`, яка логить команди у `AsyncStorage`, забезпечує повторні спроби та відпрацьовує їх у фоні без блокування UI.【F:src/services/IngredientCommandQueue.ts†L1-L132】 Ініціалізація черги відбувається під час старту застосунку.【F:App.tsx†L1-L120】
3. **Інкрементальний перезапуск кешу.** Після кожної оптимістичної зміни кеш доступності оновлюється лише для дотичних інгредієнтів, що прибирає необхідність повного перерахунку під час серії тумблерів.【F:src/domain/ingredientsAvailabilityCache.ts†L40-L83】

## Пропозиція 1. Подієвий шар команд + фонова синхронізація
1. **Виділити єдиний store для інгредієнтів на базі Zustand/Redux Toolkit** з нормалізованим станом (`byId`, `ids`). Команди на кшталт `toggleInBar` або `setShoppingState` негайно змінюють store та кеш доступності на JS-потоці, забезпечуючи миттєвий відгук UI.
2. **Увести окремий модуль `IngredientCommandBus`**, що приймає команди з UI та зберігає їх у локальному логі (наприклад, AsyncStorage/MMKV). Кожна команда містить payload (`ids`, нове значення) і timestamp.
3. **Фонова worker-процесія** (JSI worklet або `expo-task-manager`) читає лог команд та застосовує їх батчем до SQLite, використовуючи один `UPDATE` з усіма ID. Після підтвердження worker позначає команду як виконану. У випадку помилок worker повторює застосування або відкатує команду.
4. **Переваги:**
   - UI не блокується на `await toggleIngredientsInBar`, тому користувач не відчуває затримок.
   - Батчування в worker мінімізує кількість `BEGIN IMMEDIATE` і зменшує контеншн на глобальній черзі.
   - Лог команд можна легко синхронізувати з бекендом у майбутньому.

## Пропозиція 2. Перехід на JSI-first сховище з синхронним API
1. Замінити `expo-sqlite` на JSI-бібліотеку з нативним бекендом (наприклад, `react-native-quick-sqlite` або власний модуль), яка дозволяє виконувати записні операції поза JS-потоком.
2. Побудувати тонкий data-access шар, де `toggleInBar` викликає синхронний JSI-метод, що виконує SQL без Promise/черги. Це прибирає JS locking та дозволяє виконувати декілька оновлень паралельно.
3. Додатково використати **оптимістичні оновлення** store з Пропозиції 1 для миттєвої реакції UI.
4. Для сумісності з існуючим кодом доменний шар (`src/domain/ingredients.ts`) залишається ізоморфним, але реалізація `ingredients` data-layer підміняється новим бекендом через `__setDataLayer` під час ініціалізації.

## Пропозиція 3. Індекси доступності як окремий сервіс
1. Винести логіку `ingredientsAvailabilityCache` у окремий Worker (JSI або `react-native-worker`). Worker отримує повідомлення про зміну інгредієнтів (ідентифікатори та нові поля) і підтримує власні мапи `ingredients`, `cocktails`, `usage`.
2. Worker повертає лише дельти (наприклад, `{ id, count, single }`), які застосовуються до UI store. Таким чином не потрібно реконструювати Map в React state і викликати re-render великих списків.
3. Коли worker завершує обчислення, він може згенерувати аналітику (наприклад, скільки коктейлів стало доступними) без блокування головного потоку.
4. Якщо об’єднати з Пропозицією 1, UI отримує оновлення доступності асинхронно, але без масового копіювання Map у React state.

## Очікувані результати
- Скорочення часу очікування користувача до <50 мс на одну зміну завдяки оптимістичним оновленням та роботі в памʼяті.
- Зменшення навантаження на глобальну чергу `withWriteTransactionAsync`, оскільки записи виконуються батчами або поза JS-потоком.
- Масштабованість: лог команд + worker дозволяє легко додати синхронізацію з сервером або ведення історії змін без модифікації UI.
